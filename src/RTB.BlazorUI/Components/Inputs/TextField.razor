@using System.Threading
@using RTB.Blazor.Components.Layout
@using RTB.Blazor.Styles

@implements IDisposable

@inherits RTBComponent

@code {
    [Parameter] public string? LabelClass { get; set; }
    [Parameter] public TextStyle? LabelTextStyle { get; set; }
    [Parameter] public string? LabelText { get; set; }
    [Parameter] public RenderFragment? LabelContent { get; set;}
    [Parameter] public string? Placeholder { get; set; }

    [Parameter] public string Value { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> ValueChanged { get; set; } = default!;
    [Parameter] public EventCallback<string> OnChange { get; set; }

    [Parameter] public string? InputClass { get; set; }
    [Parameter] public TextFieldStyle? InputStyle { get; set; }

    [Parameter] public int DebounceMilliseconds { get; set; } = 100;

    [Parameter] public bool Immediate { get; set; }

    [Parameter] public bool Nummeric { get; set; }

    [Parameter] public bool ReadOnly { get; set; } = false;

    [Parameter] public bool ClearOnFocusIn { get; set; }
    [Parameter] public bool ClearOnFocusOut { get; set; }
    [Parameter] public EventCallback OnFocusIn { get; set; }
    [Parameter] public EventCallback OnFocusOut { get; set; }

    private readonly string _id = $"rtb-tf-{Guid.NewGuid():N}";

    private Timer? _debounceTimer;
    private readonly object _debounceLock = new();

    private async Task OnInput(ChangeEventArgs e)
    {
        if (ReadOnly) return;

        var text = e.Value?.ToString() ?? string.Empty;
        if (text == Value) return;

        if (Immediate)
        {
            await ValueChanged.InvokeAsync(text);
            await OnChange.InvokeAsync(text);
            return;
        }

        lock (_debounceLock)
        {
            _debounceTimer?.Dispose(); // nuke any previous timer
            _debounceTimer = new Timer(async _ =>
            {
                await InvokeAsync(() => ValueChanged.InvokeAsync(text));
                await InvokeAsync(() => OnChange.InvokeAsync(text));
                _debounceTimer?.Dispose(); // clean up after firing

            }, null, DebounceMilliseconds, Timeout.Infinite);
        }
    }

    public void Dispose()
    {
        _debounceTimer?.Dispose();
    }
}

<GridView Rows="auto auto" Class="@Class">
    @if (LabelContent is not null || !string.IsNullOrEmpty(LabelText))
    {
        <label for="@_id" class="@LabelClass">
            @(LabelContent ?? (@<RTBText TextStyle="@LabelTextStyle">@LabelText</RTBText>))
        </label>
    }

    <Styled Context="InputStyleClass">
        <PreStyled Style="@InputStyle" />

        <input 
            id="@_id"
            disabled="@ReadOnly"
            value="@Value"
            type="@(Nummeric ? "number" : "text")"
            placeholder="@Placeholder"
            class="@CombineClass("rtb-tf", InputStyleClass, InputClass)" 
            @oninput="OnInput"
            @onfocusin="InternalOnFocusIn"
            @onfocusout="InternalOnFocusOut"
        />
    </Styled>
</GridView>

@code {
    private void InternalOnFocusIn(FocusEventArgs args)
    {
        if (OnFocusIn.HasDelegate) OnFocusIn.InvokeAsync();
        if (ClearOnFocusIn) Clear();
    }

    private void InternalOnFocusOut(FocusEventArgs args)
    {
        if (OnFocusOut.HasDelegate) OnFocusOut.InvokeAsync();
        if (ClearOnFocusOut) Clear();
    }

    private void Clear()
    {
        Value = string.Empty;
        if (ValueChanged.HasDelegate) 
            ValueChanged.InvokeAsync(Value);
    }
}
