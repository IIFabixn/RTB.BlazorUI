@inherits ComponentBase
@using RTB.Blazor.Styled.Core
@using RTB.Blazor.Styled.Services
@inject IStyleRegistry Registry

<CascadingValue Value="_builder" Name="StyleBuilder" IsFixed="true">
    @ChildContent?.Invoke(CssClass)
</CascadingValue>

@code {
    [Parameter] public RenderFragment<string>? ChildContent { get; set; }

    // Optional extra class from the caller
    [Parameter] public string? Class { get; set; }

    // Optional externally-controlled class name (two-way bindable)
    [Parameter] public string? Classname { get; set; }
    [Parameter] public EventCallback<string?> ClassnameChanged { get; set; }

    [Parameter] public Action<StyleBuilder>? Configure { get; set; }

    private readonly StyleBuilder _builder = StyleBuilder.Start;

    private string? _resolvedClass;   // the class this component uses
    private string? _lastCss;         // memoized last emitted CSS

    private string CssClass
        => string.IsNullOrWhiteSpace(Class)
            ? _resolvedClass ?? ""
            : string.IsNullOrWhiteSpace(_resolvedClass) ? Class! : $"{_resolvedClass} {Class}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (string.IsNullOrWhiteSpace(_resolvedClass))
            _resolvedClass = Registry.Acquire(Classname);

        Configure?.Invoke(_builder);
        _builder.Compose();
        // Build CSS already scoped to the resolved class
        var css = _builder.BuildScoped(_resolvedClass);
        if (string.IsNullOrEmpty(css))
            return;

        // Skip if nothing changed
        if (string.Equals(css, _lastCss, StringComparison.Ordinal))
            return;

        // Inject as-is (JS should *not* scope again; it should clear+append)
        await Registry.UpsertScopedAsync(css, _resolvedClass);

        _lastCss = css;

        // Keep two-way binding in sync (only if parent didn't provide a fixed Classname)
        if (Classname != _resolvedClass && ClassnameChanged.HasDelegate)
            await ClassnameChanged.InvokeAsync(_resolvedClass);

        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (!string.IsNullOrWhiteSpace(_resolvedClass))
            await Registry.Release(_resolvedClass);
    }
}