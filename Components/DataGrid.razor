@using RTB.BlazorUI.Extensions
@using RTB.BlazorUI.Interfaces
<!-- DataGrid.razor ------------------------------------------------------>
@typeparam TRow
@attribute [CascadingTypeParameter(nameof(TRow))]

@inherits RTBComponent
@implements IRegister<ColumnBase<TRow>>


@code {
    [Parameter] public IEnumerable<TRow> Items { get; set; } = [];
    [Parameter] public RenderFragment ChildContent { get; set; } = default!;

    [Parameter] public TRow? SelectedRow { get; set; }
    [Parameter] public EventCallback<TRow>? SelectedRowChanged { get; set; }

    [Parameter] public string? HeaderClass { get; set; }

    [Parameter, EditorRequired] public string KeyProperty { get; set; } = default!;
}

<CascadingValue Value="this">
    <!-- registers the <DataColumn>s -->
    @ChildContent
</CascadingValue>

<div class="h-full w-full"> <!-- wrapping div in order to have functioning scrolling.. -->
    <div class="grid sticky top-0 z-10 border-b @(CapturedAttributes.GetValueOrDefault("class"))"
        style="grid-template-columns:@GridTemplate">

        <!-- ---------- Header cells (row 1) ------------------------ -->
        @foreach (var col in _columns)
        {
            <div class="p-2 font-medium sticky top-0
                select-none cursor-pointer z-10 bg-inherit border-b border-b-slate-300 flex items-center justify-between @HeaderClass @(col.CapturedAttributes.GetValueOrDefault("class"))"
            @onclick="() => ToggleSort(col)">
                @col.RenderHeader
                @if (Sort?.Column == col)
                {
                    <span>@(Sort.Descending ? "▼" : "▲")</span>
                }
            </div>
        }

        <!-- ---------- Data cells (rows 2…N) ----------------------- -->
        @for (var rowIdx = 0; rowIdx < _sortedItems.Count; rowIdx++)
        {
            var row = _sortedItems[rowIdx];
            var rowId = row?.GetType().GetProperty(KeyProperty)?.GetValue(row)?.ToString() ?? rowIdx.ToString();
            var isSelected = _selectedRow?.Equals(row) ?? false;
            for (var colIdx = 0; colIdx < _columns.Count; colIdx++)
            {
                var col = _columns[colIdx];
                <div role="cell"
                    @key="@($"{col.Guid}_{rowId}")"
                    class="p-2 @(isSelected ? "bg-red-100" : rowIdx % 2 == 0 ? "bg-slate-50" : "bg-white")"
                    @onclick="() => SelectRow(row)">
                    @(builder => col.RenderCell(builder, row))
                </div>
            }
        }
    </div>
</div>

@code {
    private List<ColumnBase<TRow>> _columns = [];
    private SortInfo? _sort;
    private SortInfo? Sort
    {
        get => _sort;
        set => SetProperty(ref _sort, value);
    }

    private List<TRow> _sortedItems = [];
    private TRow? _selectedRow;

    protected override void OnParametersSet()
    {
        if (Sort is null)
        {
            var firstSortable = _columns.FirstOrDefault(c => c.CanSort);
            if (firstSortable is not null)
                Sort = new(firstSortable, firstSortable.DefaultSortDescending);
        }

        _selectedRow = SelectedRow;
        SetProperty(ref _sortedItems, SortItems().ToList());
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;
        if (_columns.Count == 0) return; // no columns registered

        Sort ??= _columns.TryGetItem(i => i.CanSort, out var col) ? new(col, col.DefaultSortDescending) : null;

        SetProperty(ref _sortedItems, SortItems().ToList());
        StateHasChanged(); // trigger rerender
    }

    private IEnumerable<TRow> SortItems()
    {
        if (Sort is { Column.SortKey: not null } s)
        {
            return s.Descending
                ? Items.OrderByDescending(s.Column.SortKey!)
                : Items.OrderBy(s.Column.SortKey!);
        }

        return Items;
    }

    private string GridTemplate => string.Join(' ', _columns.Select(c =>
    {
        if (c.MinWidth != null || c.MaxWidth != null)
        {
            var min = c.MinWidth ?? "auto";
            var max = c.MaxWidth ?? "1fr";
            return $"minmax({min}, {max})";
        }

        return c.Width ?? "auto";
    }));

    public void Register(ColumnBase<TRow> column)
    {
        if (_columns.Any(i => i.Guid == column.Guid)) return;

        _columns.Add(column);
        StateHasChanged();
    }

    public void Unregister(ColumnBase<TRow> column)
    {
        if (!_columns.Any(i => i.Guid == column.Guid)) return;
        
        _columns.Remove(column);
        StateHasChanged();
    }

    private void ToggleSort(IColumn<TRow> column)
    {
        if (!column.CanSort) return;

        Sort = Sort?.Column == column
            ? Sort with { Descending = !Sort.Descending }  // toggle direction
            : new(column, column.DefaultSortDescending);     // new column selected

        SetProperty(ref _sortedItems, SortItems().ToList());
    }

    private record SortInfo(IColumn<TRow> Column, bool Descending);

    private void SelectRow(TRow row)
    {
        SetProperty(ref _selectedRow, row);
        
        SelectedRowChanged?.InvokeAsync(_selectedRow);
    }
}